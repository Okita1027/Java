## 开闭原则
***
**对扩展开放，对修改关闭** <br/>
**在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效
果。简言之，是为了使程序的扩展性好，易于维护和升级。**<br/>
想要达到这样的效果，我们需要使用接口和抽象类。<br/>
因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节
可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类
来扩展就可以了。
## 里氏代换原则
***
**里氏代换原则：任何基类可以出现的地方，子类一定可以出现。通俗理解：子类可以扩展父类的功能，
但不能改变父类原有的功能。换句话说，子类继承父类时，除添加新的方法完成新增功能外，尽量不要
重写父类的方法**<br/>
如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较
差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。
## 依赖倒转原则
***
**高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。简
单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。**<br/>
【例】组装电脑
现要组装一台电脑，需要配件cpu，硬盘，内存条。只有这些配置都有了，计算机才能正常的运行。选
择cpu有很多选择，如Intel，AMD等，硬盘可以选择希捷，西数等，内存条可以选择金士顿，海盗船
等。**但是**，组装的电脑的cpu只能是Intel的，内存条只能是金 士顿的，硬盘只能是希捷的。<br/>
此时要将CPU、内存条、硬盘转成接口，用实现类定义不同的品牌。
## 接口隔离原则
***
**客户端不应该被迫依赖于它不使用的方法；一个类对另一个类的依赖应该建立在最小的接口上。**<br/>
创建一个 黑马 品牌的安全门，该安全门具有防火、防水、防盗的功能。可以将防火，防水，防
盗功能提取成一个接口，形成一套规范。<br/>
现在如果我们 还需要再创建一个传智品牌的安全门，而该安全门只具有防盗、防水功能呢？很显然如果实现
SafetyDoor接口就违背了接口隔离原则。<br/>
因此要将防火、防水、防盗的功能分成三个接口实现。
## 迪米特法则/最小知识原则
***
**只和你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and
not to strangers）。**<br/>
**如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发
该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。**<br/>
**迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象
的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。**<br/>
【例】明星与经纪人的关系实例
明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如和粉丝的见面会，和媒体公司的业
务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则。
